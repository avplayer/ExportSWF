<?xml version="1.0" encoding="utf-8"?>
<s:WindowedApplication xmlns:fx="http://ns.adobe.com/mxml/2009"
					   xmlns:s="library://ns.adobe.com/flex/spark"
					   xmlns:mx="library://ns.adobe.com/flex/mx"
					   minWidth="800" minHeight="600" backgroundColor="#424242" contentBackgroundColor="#424242">
	<fx:Script>
		<![CDATA[
			import mx.collections.ArrayList;
			import mx.graphics.codec.PNGEncoder;
			import mx.utils.StringUtil;
			private var file:File;
			
			private var loader:Loader;
			
			private var images:ArrayList = new ArrayList();
			
			private var movieClips:Object;
			
			[Bindable]
			private var exportPath:String;
			
			protected function browseInputFile_clickHandler(event:MouseEvent):void
			{
				file = new File;
				file.browse([new FileFilter("swf files", "*.swf", "SWF")]);
				file.addEventListener(Event.SELECT, onSelected);
			}
			
			protected function onSelected(event:Event):void
			{
				images.removeAll();
				inputFile.text = file.nativePath;
				file.load();
				file.addEventListener(Event.COMPLETE, onLoadComplete);
			}
			
			protected function onLoadComplete(event:Event):void
			{
				var ad:ApplicationDomain = new ApplicationDomain;
				var lc:LoaderContext =  new LoaderContext(false, ad);
				lc.allowCodeImport = true;
				loader = new Loader();
				loader.loadBytes(file.data, lc);
				loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onSwfLoadComplete);
			}
			
			private function nextFrame(mc:MovieClip):void
			{
				mc.nextFrame();
				for(var i = 0; i < mc.numChildren; i++)
				{
					var childMC:MovieClip = mc.getChildAt(i) as MovieClip;
					if(childMC)
						nextFrame(childMC);
				}
			}
			
			private function dumpMC(mc:MovieClip):void
			{
				var bd:BitmapData;
				var mcBounds:Rectangle = new Rectangle();
				var items:Array = [];
				var offsetX:Number = 1000;
				var offsetY:Number = 1000;
				movieClips[mc.name] = [];
				for(var i = 0; i < mc.totalFrames; i++)
				{
					var bounds:Rectangle = mc.getBounds(mc);
					bd = new BitmapData(bounds.width + offsetX * 2, bounds.height + offsetY * 2, true, 0);
					var matrix:Matrix = new Matrix();
					matrix.translate(offsetX, offsetY);
					
					bd.draw(mc, matrix);
					items.push(bd);
					nextFrame(mc);
					mcBounds = mcBounds.union(bounds);
				}
				
				for(var i = 0; i < items.length; i++)
				{
					var bd:BitmapData = new BitmapData(mcBounds.width, mcBounds.height, true, 0);
					var matrix:Matrix = new Matrix();
					matrix.translate(-offsetX - mcBounds.left, -offsetY - mcBounds.top);
					bd.draw(items[i], matrix);
					images.addItem({bitmap:bd, name:mc.name});
					movieClips[mc.name].push(bd);
				}
				mc.x = -mcBounds.left;
				mc.y = -mcBounds.top;
				
				trace(mc.name);
				trace(mcBounds.left, mcBounds.top, mc.width, mc.height);
				
			}
			
			protected function onSwfLoadComplete(event:Event):void
			{
				var container:MovieClip = event.target.content as MovieClip;
				movieClips = {};
				trace(container.numChildren);
				for(var i = 0; i < container.numChildren; i++)
				{
					var mc:MovieClip = container.getChildAt(i) as MovieClip;
					if(mc)
					{
						dumpMC(mc);
						mc.play();
					}
				}
			}
			
			var saveFile:File;
			protected function browseExportPath_clickHandler(event:MouseEvent):void
			{
				saveFile = new File();
				saveFile.browseForDirectory("select export path");
				saveFile.addEventListener(Event.SELECT, onExportPathSelected);
			}
			
			protected function onExportPathSelected(event:Event):void
			{
				exportPath = saveFile.nativePath;
			}
			
			protected function calcSize(width:Number, height:Number, num:Number):Rectangle
			{
				var n:Number = 0;
				var p:Point = new Point;
				var row:Number = 0;
				var col:Number = 0;
				while(n < num)
				{
					if(p.y >= p.x)
					{
						col++;
						p.x = p.x + width;
					} else {
						row++;
						p.y = p.y + height;
					}
					n = col*row;
				}
				return new Rectangle(0, 0, col * width, row * height);
			}
			
			protected function export_clickHandler(event:MouseEvent):void
			{
				var encoder:PNGEncoder = new PNGEncoder;
				for(var name:String in movieClips)
				{
					var png:FileStream = new FileStream;
					png.open(new File(exportPath + File.separator + name + ".png"), FileMode.WRITE);
					var plistFile:FileStream = new FileStream;
					plistFile.open(new File(exportPath + File.separator + name + ".plist"), FileMode.WRITE);
					var bd:BitmapData = null;
					var matrix:Matrix = new Matrix;
					var size:Rectangle;
					var plist:XML = new XML(<plist version="1.0"><dict/></plist>);
					plist.dict.appendChild(<key>frames</key>);
					var frames:XML = new XML(<dict></dict>);
					for(var i = 0; i < movieClips[name].length; i++)
					{
						var frame:BitmapData = movieClips[name][i] as BitmapData;
						if(bd == null)
						{
							size = calcSize(frame.width, frame.height, movieClips[name].length);
							bd = new BitmapData(size.width, size.height, true, 0);
						}
						bd.draw(frame, matrix);
						var frameXML:XML = <dict></dict>;
						var offsetStr:String = StringUtil.substitute("{{0},{1}}", matrix.tx, matrix.ty);
						var sizeStr:String = StringUtil.substitute("{{0},{1}}", frame.width, frame.height);
						var rect:String = StringUtil.substitute("{{0},{1}}", offsetStr, sizeStr);
						frameXML.appendChild(<key>sourceColorRect</key>);
						frameXML.appendChild(<string>{rect}</string>);
						frameXML.appendChild(<key>spriteOffset</key>);
						frameXML.appendChild(<string>&#123;0,0&#125;</string>);
						frameXML.appendChild(<key>spriteSize</key>);
						frameXML.appendChild(<string>{sizeStr}</string>);
						frameXML.appendChild(<key>spriteSourceSize</key>);
						frameXML.appendChild(<string>{sizeStr}</string>);
						frameXML.appendChild(<key>spriteTrimmed</key>);
						frameXML.appendChild(<false/>);
						frameXML.appendChild(<key>textureRect</key>);
						frameXML.appendChild(<string>{rect}</string>);
						frameXML.appendChild(<key>textureRotated</key>);
						frameXML.appendChild(<false/>);		
						
						frames.appendChild(<key>{name}{uint_Zeropadded(i, 4)}</key>);
						frames.appendChild(frameXML);
						
						
						matrix.translate(frame.width, 0);
						if(matrix.tx >= size.width)
						{
							matrix.tx = 0;
							matrix.ty += frame.height;
						}
					}
					plist.dict.appendChild(frames);
					plist.dict.appendChild(<key>metadata</key>);
					plist.dict.appendChild(
						<dict>
							<key>format</key>
							<integer>3</integer>
							<key>size</key>
							<string>&#123;{size.width},{size.height}&#125;</string>
							<key>target</key>
							<dict>
								<key>name</key>
								<string>{name}.png</string>
								<key>textureFileName</key>
								<string>{name}</string>
								<key>textureFileExtension</key>
								<string>png</string>
								<key>premultipliedAlpha</key>
								<true/>
							</dict>
						</dict>);
					
					plistFile.writeUTFBytes(plist.toXMLString());
					var ba:ByteArray = encoder.encode(bd);
					png.writeBytes(ba);
					png.close();
				}
			}
			
			private static const _ZEROS:String = "0000000000000000000000000000000000000000"; // 40 zeros, shorten/expand as you wish
			
			/*
			* f: positive integer value
			* z: maximum number of leading zeros of the numeric part (sign takes one extra digit)
			*/
			public static function uint_Zeropadded(f:uint, z:int = 0):String {
				var result:String = f.toString();
				while (result.length < z)
					result = _ZEROS.substr(0, z - result.length) + result;
				return result;
			}
		]]>
	</fx:Script>
	
	<fx:Declarations>
		<!-- 将非可视元素（例如服务、值对象）放在此处 -->
	</fx:Declarations>
	
	<s:Group>
		
		<s:layout>
			<s:VerticalLayout/>
		</s:layout>
		
		<s:Group id="inputFileBox">
			<s:layout>
				<s:HorizontalLayout/>
			</s:layout>
			<s:TextInput id="inputFile" editable="false"/>
			<s:Button id="browseInputFile" label="browse input file"
					  click="browseInputFile_clickHandler(event)"/>
		</s:Group>
		<s:Group>
			<s:layout>
				<s:HorizontalLayout/>
			</s:layout>
			<s:List width="600" height="400" dataProvider="{images}" horizontalScrollPolicy="on"
					itemRenderer="com.github.hyqhyq3.ImageItem">
				<s:layout>
					<s:HorizontalLayout/>
				</s:layout>
			</s:List>
			
			<mx:UIComponent id="ui"/>
		</s:Group>
		<s:Label id="totalFrames" text="{images.length}"/>
		<s:Group>
			<s:layout>
				<s:HorizontalLayout/>
			</s:layout>
			<s:Label>
				导出路径：
			</s:Label>
			<s:TextInput id="exportPathText" text="@{exportPath}"/>
			<s:Button id="browseExportPath" label="browse export path"
					  click="browseExportPath_clickHandler(event)"/>
		</s:Group>
		
		<s:Button id="export" label="export" click="export_clickHandler(event)"
				  enabled="{exportPath.length &gt; 0}"/>
	</s:Group>
</s:WindowedApplication>
